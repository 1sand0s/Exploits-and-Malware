package PDA;

import java.io.IOException;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import jdk.nashorn.internal.runtime.options.Options;

import org.pcap4j.core.BpfProgram.BpfCompileMode;
import org.pcap4j.core.NotOpenException;
import org.pcap4j.core.PacketListener;
import org.pcap4j.core.PcapHandle;
import org.pcap4j.core.PcapNativeException;
import org.pcap4j.core.PcapNetworkInterface;
import org.pcap4j.core.PcapNetworkInterface.PromiscuousMode;
import org.pcap4j.core.Pcaps;
import org.pcap4j.packet.ArpPacket;
import org.pcap4j.packet.EthernetPacket;
import org.pcap4j.packet.IcmpV4CommonPacket;
import org.pcap4j.packet.IcmpV4EchoPacket;
import org.pcap4j.packet.IcmpV4EchoReplyPacket;
import org.pcap4j.packet.IcmpV4InformationRequestPacket;
import org.pcap4j.packet.IcmpV4TimestampPacket;
import org.pcap4j.packet.IpV4Packet;
import org.pcap4j.packet.IpV4Rfc791Tos;
import org.pcap4j.packet.Packet;
import org.pcap4j.packet.UnknownPacket;
import org.pcap4j.packet.namednumber.ArpHardwareType;
import org.pcap4j.packet.namednumber.ArpOperation;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.packet.namednumber.IcmpV4Code;
import org.pcap4j.packet.namednumber.IcmpV4Type;
import org.pcap4j.packet.namednumber.IpNumber;
import org.pcap4j.packet.namednumber.IpV4OptionType;
import org.pcap4j.packet.namednumber.IpV4OptionType.IpV4OptionClass;
import org.pcap4j.packet.namednumber.IpVersion;
import org.pcap4j.util.ByteArrays;
import org.pcap4j.util.MacAddress;
import org.pcap4j.util.NifSelector;

@SuppressWarnings("javadoc")
public class pingtest {

  private static final String COUNT_KEY
    = pingtest.class.getName() + ".count";
  private static final int COUNT
    = Integer.getInteger(COUNT_KEY, 1);

  private static final String READ_TIMEOUT_KEY
    = pingtest.class.getName() + ".readTimeout";
  private static final int READ_TIMEOUT
    = Integer.getInteger(READ_TIMEOUT_KEY, 10); // [ms]

  private static final String SNAPLEN_KEY
    = pingtest.class.getName() + ".snaplen";
  private static final int SNAPLEN
    = Integer.getInteger(SNAPLEN_KEY, 65536); // [bytes]

  private static final MacAddress SRC_MAC_ADDR
    = MacAddress.getByName("e4:d5:3d:e5:55:3d");

  private static MacAddress resolvedAddr;

  public static void main(String[] args) throws PcapNativeException, NotOpenException, UnknownHostException {
    String strSrcIpAddress = "192.168.1.3"; // for InetAddress.getByName()
    String strDstIpAddress ="192.168.1.1"; // for InetAddress.getByName()

    System.out.println(COUNT_KEY + ": " + COUNT);
    System.out.println(READ_TIMEOUT_KEY + ": " + READ_TIMEOUT);
    System.out.println(SNAPLEN_KEY + ": " + SNAPLEN);
    System.out.println("\n");

    PcapNetworkInterface nif;
    try {
      nif = new NifSelector().selectNetworkInterface();
    } catch (IOException e) {
      e.printStackTrace();
      return;
    }

    if (nif == null) {
      return;
    }

    System.out.println(nif.getName() + "(" + nif.getDescription() + ")");

    PcapHandle handle
      = nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);
    PcapHandle sendHandle
      = nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);
    ExecutorService pool = Executors.newSingleThreadExecutor();

    try {
      handle.setFilter(
        "icmp and dst host " + strSrcIpAddress,
        BpfCompileMode.OPTIMIZE
      );

      PacketListener listener = new PacketListener() 
		{
			  @Override
			  public void gotPacket(Packet packet) 
			  {
			
				  if (packet.contains(IpV4Packet.class))
				  {
					  IpV4Packet ipv4=packet.get(IpV4Packet.class);
					  if(ipv4.contains(IcmpV4CommonPacket.class))
					  {
					
						  IcmpV4CommonPacket icmp_reply=packet.get(IcmpV4CommonPacket.class);
						  if (icmp_reply.getHeader().getType().equals(IcmpV4Type.TIMESTAMP_REPLY))
						  {
							 
							  IcmpV4EchoReplyPacket pac=icmp_reply.get(IcmpV4EchoReplyPacket.class);
							//  recv_data=new String(pac.getRawData());
						  }
						  
					  }
					  	
					  
				  }
			  }
		  };

      Task t = new Task(handle, listener);
      pool.execute(t);

      UnknownPacket.Builder unknownb = new UnknownPacket.Builder();
      unknownb.rawData(new byte[]{0,1,2,3});

      IcmpV4TimestampPacket.Builder pppp=new IcmpV4TimestampPacket.Builder();
     // IcmpV4DestinationUnreachablePacket.Builder pppp=new IcmpV4DestinationUnreachablePacket.Builder();
     // pppp.payloadBuilder(unknownb);
     pppp.sequenceNumber((short) 70);
     pppp.originateTimestamp(70);
     pppp.identifier((short) 300);
     // pppp.receiveTimestamp(150);
      IcmpV4CommonPacket.Builder pac =new IcmpV4CommonPacket.Builder();
   
    	  pac
    	  .code(IcmpV4Code.NO_CODE)
    	  .type(IcmpV4Type.TIMESTAMP)
    	  .correctChecksumAtBuild(true)
    	  
    	  .payloadBuilder(pppp);
    	  
  
      IpV4Packet.Builder pp=new IpV4Packet.Builder();
      pp
      .correctChecksumAtBuild(true)
   
      .dstAddr((Inet4Address) InetAddress.getByName("216.58.197.78"))
      .srcAddr((Inet4Address)InetAddress.getByName("192.168.1.3"))
      .payloadBuilder(pac)
      .version(IpVersion.IPV4)
     
         .tos(IpV4Rfc791Tos.newInstance((byte)0))
         .identification((short)100)
         .ttl((byte)100)
         .protocol(IpNumber.ICMPV4)
         .correctLengthAtBuild(true);

      EthernetPacket.Builder etherBuilder = new EthernetPacket.Builder();
      etherBuilder.dstAddr(MacAddress.getByName("00:26:15:66:a2:bd"))
                  .srcAddr(SRC_MAC_ADDR)
                  .type(EtherType.IPV4)
                  .payloadBuilder(pp)
                  .paddingAtBuild(true);

      for (int i = 0; i < COUNT; i++) {
        Packet p = etherBuilder.build();
        System.out.println(p);
        sendHandle.sendPacket(p);
        try {
          Thread.sleep(1000);
        } catch (InterruptedException e) {
          break;
        }
      }
    } finally {
      if (handle != null && handle.isOpen()) {
        handle.close();
      }
      if (sendHandle != null && sendHandle.isOpen()) {
        sendHandle.close();
      }
      if (pool != null && !pool.isShutdown()) {
        pool.shutdown();
      }

      System.out.println(strDstIpAddress + " was resolved to " + resolvedAddr);
    }
  }

  private static class Task implements Runnable {

    private PcapHandle handle;
    private PacketListener listener;

    public Task(PcapHandle handle, PacketListener listener) {
      this.handle = handle;
      this.listener = listener;
    }

    @Override
    public void run() {
      try {
        handle.loop(COUNT, listener);
      } catch (PcapNativeException e) {
        e.printStackTrace();
      } catch (InterruptedException e) {
        e.printStackTrace();
      } catch (NotOpenException e) {
        e.printStackTrace();
      }
    }

  }

}
