/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package PDA;

import java.awt.Color;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.image.BufferedImage;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import javax.imageio.ImageIO;
import javax.swing.JOptionPane;

import org.pcap4j.core.NotOpenException;
import org.pcap4j.core.PacketListener;
import org.pcap4j.core.PcapHandle;
import org.pcap4j.core.PcapNativeException;
import org.pcap4j.core.PcapNetworkInterface;
import org.pcap4j.core.Pcaps;
import org.pcap4j.core.BpfProgram.BpfCompileMode;
import org.pcap4j.core.PcapNetworkInterface.PromiscuousMode;
import org.pcap4j.packet.IcmpV4CommonPacket;
import org.pcap4j.packet.IcmpV4EchoReplyPacket;
import org.pcap4j.packet.IpV4Packet;
import org.pcap4j.packet.Packet;
import org.pcap4j.packet.namednumber.IcmpV4Type;
import org.pcap4j.util.MacAddress;

import com.sun.jna.Native;
import com.sun.jna.NativeLibrary;
import com.sun.org.apache.xml.internal.security.utils.Base64;



public class pda extends javax.swing.JFrame implements ActionListener , KeyListener
{

	  private javax.swing.JButton Ping;
	  private javax.swing.JButton IP_Spoof;
	  private javax.swing.JButton Arp;
	  private javax.swing.JButton NIC;
	  private javax.swing.JButton MAC;
	  private javax.swing.JButton Exit;
	  private javax.swing.JButton jButton7;
	  protected static boolean shutdown=false;
	  
	  protected static String srcIP="192.168.1.3";
	  protected static String destIP="";
	  protected static String srcMAC="";
	  protected static String raw="";
	  protected static byte[] raw1;
	  protected static PcapNetworkInterface nif;
	  protected static javax.swing.JTextArea field;
	  private javax.swing.JScrollPane scroll;
	  protected static String input="";
	  protected static Object lock=new Object();
	  javax.swing.JFrame frame;

	  public pda() 
	  {
        initComponents();
	  }




                        
    private void initComponents() 
    {

        Arp = new javax.swing.JButton();
        field = new javax.swing.JTextArea();
        field.setText("\n\tCCN LAB OPEN ENDED\n\n\tPing Disguised Attack");
        Ping = new javax.swing.JButton();
        IP_Spoof = new javax.swing.JButton();
        NIC = new javax.swing.JButton();
        MAC = new javax.swing.JButton();
        Exit = new javax.swing.JButton();
        jButton7 = new javax.swing.JButton();
        scroll=new javax.swing.JScrollPane(field);
        field.setBackground(Color.BLACK);
        field.setForeground(Color.GREEN);
        frame=this;
        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
       
        Arp.setText("Arp");

        Ping.setText("Ping");
        
        IP_Spoof.setText("IP Spoof");
      
        NIC.setText("NIC");

        MAC.setText("MAC");

        Exit.setText("Exit");
       
        jButton7.setText("Ping");
        
        Ping.addActionListener(this);
        IP_Spoof.addActionListener(this);
        Arp.addActionListener(this);
        NIC.addActionListener(this);
        field.addKeyListener(this);
        MAC.addActionListener(this);
        Exit.addActionListener(this);
       
        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addComponent(scroll, javax.swing.GroupLayout.PREFERRED_SIZE, 284, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Ping)
                        .addGap(18, 18, 18)
                        .addComponent(IP_Spoof))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(Arp)
                        .addGap(18, 18, 18)
                        .addComponent(NIC))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(MAC)
                        .addGap(18, 18, 18)
                        .addComponent(Exit))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(scroll)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Ping)
                    .addComponent(IP_Spoof))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(Arp)
                    .addComponent(NIC))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(Exit)
                    .addComponent(MAC))
                .addGap(0, 209, Short.MAX_VALUE))
        );

        pack();
    }                   

                                      

    public static void main(String args[]) 
    {
    	Native.DEBUG_LOAD=true;
    	
    	
       
        try 
        {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) 
            {
                if ("Nimbus".equals(info.getName())) 
                {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } 
        catch (ClassNotFoundException ex) 
        {
            java.util.logging.Logger.getLogger(pda.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } 
        catch (InstantiationException ex)
        {
            java.util.logging.Logger.getLogger(pda.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        catch (IllegalAccessException ex)
        {
            java.util.logging.Logger.getLogger(pda.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } 
        catch (javax.swing.UnsupportedLookAndFeelException ex) 
        {
            java.util.logging.Logger.getLogger(pda.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
  
        java.awt.EventQueue.invokeLater(new Runnable() 
        {
            public void run()
            {
                new pda().setVisible(true);
            }
        });
    }





	@Override
	public void actionPerformed(ActionEvent e)
	{
		if((e.getSource()).equals(Ping))
		{
			field.append("Ping Class\n\n");
			srcIP=JOptionPane.showInputDialog(frame,"Enter Source IP");
			field.append("Source IP is >"+srcIP+"\n\n");
			
			destIP=JOptionPane.showInputDialog(frame,"Enter Destination IP");
			field.append("Destination IP is >"+destIP+"\n\n");
			
			String data_file=JOptionPane.showInputDialog(frame,"Data or File ?\n Enter 1 for data \n 0 for file");
			String path;
			if(data_file.equalsIgnoreCase("1"))
			{
				raw=JOptionPane.showInputDialog(frame,"Enter data to be sent");
				String h="";
				for(int i=0;i<(raw.getBytes()).length;i++)
				{
					h=h+(raw.getBytes())[i]+" ";
				}
				raw1=raw.getBytes();
			}
			else
			{
				path=JOptionPane.showInputDialog(frame,"Enter path with file extension");
				File f=new File(path);
				if(path.endsWith(".class"))
				{
					Scanner k;
					try {
						k = new Scanner(f);
					} catch (FileNotFoundException e1) 
					{
						k=null;
						
						e1.printStackTrace();
					}
					String s="";
					while(k.hasNextLine())
					{
						if(s.equalsIgnoreCase(""))
						{
							s=s+k.nextLine();
						}
						else
						{
							s=s+"\n"+k.nextLine();
						}
					}
					raw="Java "+s;
					raw1=raw.getBytes();
				}
				String h="";
				
				System.out.println("lengnng "+raw.getBytes().length );
				for(int i=0;i<(raw.getBytes()).length;i++)
				{
					h=h+(raw.getBytes())[i]+" ";
				}
			}
			
			
			field.append("Payload is >"+raw+"\n\n");
			
			try 
			{
		
				new PingClass();
			}
			catch(Exception e1)
			{
				
			}
			
		}
		
		else if((e.getSource()).equals(Arp))
		{
			//new ArpClass(frame);
		}
		else if((e.getSource()).equals(NIC))
		{
			new call().start();
		}
		else if((e.getSource()).equals(MAC))
		{
			try
			{
				
				JOptionPane.showMessageDialog(frame,"Source MAC is "+srcMAC);
			}
			catch(NullPointerException e1)
			{
				JOptionPane.showMessageDialog(frame,"No NIC selected");
			}
			
		}
		else if((e.getSource()).equals(Exit))
		{
			shutdown=true;
			try 
			{
				Thread.sleep(10000);
			} 
			catch (InterruptedException e1) 
			{
		
				e1.printStackTrace();
			}
			System.exit(0);
		}
		
	}





	@Override
	public void keyTyped(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}





	@Override
	public void keyPressed(KeyEvent e) {
		// TODO Auto-generated method stub
		
	}





	@Override
	public void keyReleased(KeyEvent e)
	{
	       input=input+e.getKeyChar();
	       if(input.indexOf("\n")!=-1)
	       {
	        	synchronized(lock)
	        	{
	        		lock.notify();
	        	}
	       }
	}
}
class call extends Thread
{
	public void run()
	{
		new NICClass();
		new listen().start();
		pda.field.append("\n");
		try 
		{
			this.join();
		} 
		catch (InterruptedException e) 
		{
			e.printStackTrace();
		}
	}
}
class listen extends Thread 
{
	 private static final String COUNT_KEY= pda.class.getName() + ".count";
	 private static final int COUNT= Integer.getInteger(COUNT_KEY, 10);
	 private static final String READ_TIMEOUT_KEY = pda.class.getName() + ".readTimeout";
	 private static final int READ_TIMEOUT= Integer.getInteger(READ_TIMEOUT_KEY, 10); // [ms]
	 private static final String SNAPLEN_KEY= pda.class.getName() + ".snaplen";
	 private static final int SNAPLEN = Integer.getInteger(SNAPLEN_KEY, 65536); // [bytes]
	 private static Packet pacp;
	 private static String recv_data="";
	 
	listen() 
	{
		
	}

	public void run()
	{
	
		System.out.println("hehh  "+COUNT_KEY+"   "+COUNT+" "+READ_TIMEOUT+"  "+SNAPLEN);
		PcapHandle handle;
		try
		{
			handle = pda.nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);

		} catch (PcapNativeException e) 
		{
			handle=null;
		
			e.printStackTrace();
		}
		 ExecutorService pool = Executors.newSingleThreadExecutor();
		 try {
			handle.setFilter(
			    "icmp and dst host " + "192.168.1.3",
			    //  + " and ether dst " + Pcaps.toBpfString(MacAddress.getByName(pda.srcMAC)),
			    BpfCompileMode.OPTIMIZE
			  );
		} 
		catch (PcapNativeException e2)
		{
			
			e2.printStackTrace();
		} 
		catch (NotOpenException e2) 
		{
			
			e2.printStackTrace();
		}
		pda.field.append(handle.toString());
		PacketListener listener = new PacketListener() 
		{
			  @Override
			  public void gotPacket(Packet packet) 
			  {
			
				  if (packet.contains(IpV4Packet.class))
				  {
					  IpV4Packet ipv4=packet.get(IpV4Packet.class);
					  if(ipv4.contains(IcmpV4CommonPacket.class))
					  {
						  pacp=packet;
						  IcmpV4CommonPacket icmp_reply=packet.get(IcmpV4CommonPacket.class);
						  if (icmp_reply.getHeader().getType().equals(IcmpV4Type.ECHO_REPLY))
						  {
							 
							  IcmpV4EchoReplyPacket pac=icmp_reply.get(IcmpV4EchoReplyPacket.class);
							  recv_data=new String(pac.getRawData());
						  }
						  
					  }
					  	
					  
				  }
			  }
		  };
		  Task t=new Task(handle,listener);
		  pool.execute(t);
		  
		  try 
		  {
				Thread.sleep(5000);
		  }
		  catch (InterruptedException e1)
			{
			
				e1.printStackTrace();
			}
		while(!pda.shutdown)
		{
			if(handle.isOpen() && !recv_data.equalsIgnoreCase(""))
			{
					recv_data=recv_data.substring(4,recv_data.length());
					System.out.println(recv_data.length());
					pda.field.append(pacp.get(IpV4Packet.class).getHeader().getSrcAddr()+" Says >"+ recv_data+"\n");
					recv_data="";
			}
		}
		try
		{
			pool.shutdown();
			handle.breakLoop();
			handle.close();
		}
		catch(Exception e)
		{
			System.out.println("Handle release , Closing");
		}
		  
	}
	private static class Task implements Runnable
	{
		private PcapHandle handle;
		private PacketListener listener;
		public Task(PcapHandle handle,PacketListener listener)
		{
			this.handle=handle;
			this.listener=listener;
			
		}
		@Override
		public void run()
		{
			 try 
		      {
		    	 handle.loop(COUNT, listener);
		      } 
		      catch (PcapNativeException e) 
		      {
		        e.printStackTrace();
		      } 
		      catch (InterruptedException e) 
		      {
		        System.out.println("Closing");
		      }
		      catch (NotOpenException e) 
		      {
		        e.printStackTrace();
		      } 
		}
	}
}


